// This file was generated by counterfeiter
package fake_bbs

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs"
	"code.cloudfoundry.org/bbs/events"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeInternalClient struct {
	DesireTaskStub        func(logger lager.Logger, guid, domain string, def *models.TaskDefinition) error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		logger lager.Logger
		guid   string
		domain string
		def    *models.TaskDefinition
	}
	desireTaskReturns struct {
		result1 error
	}
	TasksStub        func(logger lager.Logger) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		logger lager.Logger
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	TasksByDomainStub        func(logger lager.Logger, domain string) ([]*models.Task, error)
	tasksByDomainMutex       sync.RWMutex
	tasksByDomainArgsForCall []struct {
		logger lager.Logger
		domain string
	}
	tasksByDomainReturns struct {
		result1 []*models.Task
		result2 error
	}
	TasksByCellIDStub        func(logger lager.Logger, cellId string) ([]*models.Task, error)
	tasksByCellIDMutex       sync.RWMutex
	tasksByCellIDArgsForCall []struct {
		logger lager.Logger
		cellId string
	}
	tasksByCellIDReturns struct {
		result1 []*models.Task
		result2 error
	}
	TaskByGuidStub        func(logger lager.Logger, guid string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		logger lager.Logger
		guid   string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	CancelTaskStub        func(logger lager.Logger, taskGuid string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	cancelTaskReturns struct {
		result1 error
	}
	ResolvingTaskStub        func(logger lager.Logger, taskGuid string) error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	resolvingTaskReturns struct {
		result1 error
	}
	DeleteTaskStub        func(logger lager.Logger, taskGuid string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	deleteTaskReturns struct {
		result1 error
	}
	DomainsStub        func(logger lager.Logger) ([]string, error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct {
		logger lager.Logger
	}
	domainsReturns struct {
		result1 []string
		result2 error
	}
	UpsertDomainStub        func(logger lager.Logger, domain string, ttl time.Duration) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		logger lager.Logger
		domain string
		ttl    time.Duration
	}
	upsertDomainReturns struct {
		result1 error
	}
	ActualLRPGroupsStub        func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupByProcessGuidAndIndexStub        func(logger lager.Logger, processGuid string, index int) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	RetireActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 error
	}
	DesiredLRPsStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DesiredLRPByProcessGuidStub        func(logger lager.Logger, processGuid string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesireLRPStub        func(lager.Logger, *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	UpdateDesiredLRPStub        func(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) error
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 error
	}
	RemoveDesiredLRPStub        func(logger lager.Logger, processGuid string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	SubscribeToEventsStub        func(logger lager.Logger) (events.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
		logger lager.Logger
	}
	subscribeToEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	PingStub        func(logger lager.Logger) bool
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		logger lager.Logger
	}
	pingReturns struct {
		result1 bool
	}
	CellsStub        func(logger lager.Logger) ([]*models.CellPresence, error)
	cellsMutex       sync.RWMutex
	cellsArgsForCall []struct {
		logger lager.Logger
	}
	cellsReturns struct {
		result1 []*models.CellPresence
		result2 error
	}
	SubscribeToDesiredLRPEventsStub        func(logger lager.Logger) (events.EventSource, error)
	subscribeToDesiredLRPEventsMutex       sync.RWMutex
	subscribeToDesiredLRPEventsArgsForCall []struct {
		logger lager.Logger
	}
	subscribeToDesiredLRPEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToActualLRPEventsStub        func(logger lager.Logger) (events.EventSource, error)
	subscribeToActualLRPEventsMutex       sync.RWMutex
	subscribeToActualLRPEventsArgsForCall []struct {
		logger lager.Logger
	}
	subscribeToActualLRPEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 error
	}
	StartActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 error
	}
	CrashActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, errorMessage string) error
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		instanceKey  *models.ActualLRPInstanceKey
		errorMessage string
	}
	crashActualLRPReturns struct {
		result1 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, errorMessage string) error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		errorMessage string
	}
	failActualLRPReturns struct {
		result1 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	EvacuateClaimedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateClaimedActualLRPMutex       sync.RWMutex
	evacuateClaimedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	evacuateClaimedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	EvacuateRunningActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) (bool, error)
	evacuateRunningActualLRPMutex       sync.RWMutex
	evacuateRunningActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
		arg5 uint64
	}
	evacuateRunningActualLRPReturns struct {
		result1 bool
		result2 error
	}
	EvacuateStoppedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateStoppedActualLRPMutex       sync.RWMutex
	evacuateStoppedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	evacuateStoppedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	EvacuateCrashedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, error)
	evacuateCrashedActualLRPMutex       sync.RWMutex
	evacuateCrashedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}
	evacuateCrashedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	RemoveEvacuatingActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	ConvergeLRPsStub        func(logger lager.Logger) error
	convergeLRPsMutex       sync.RWMutex
	convergeLRPsArgsForCall []struct {
		logger lager.Logger
	}
	convergeLRPsReturns struct {
		result1 error
	}
	ConvergeTasksStub        func(logger lager.Logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration time.Duration) error
	convergeTasksMutex       sync.RWMutex
	convergeTasksArgsForCall []struct {
		logger                      lager.Logger
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}
	convergeTasksReturns struct {
		result1 error
	}
	StartTaskStub        func(logger lager.Logger, taskGuid string, cellID string) (bool, error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
		cellID   string
	}
	startTaskReturns struct {
		result1 bool
		result2 error
	}
	FailTaskStub        func(logger lager.Logger, taskGuid, failureReason string) error
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}
	failTaskReturns struct {
		result1 error
	}
	CompleteTaskStub        func(logger lager.Logger, taskGuid, cellId string, failed bool, failureReason, result string) error
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}
	completeTaskReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInternalClient) DesireTask(logger lager.Logger, guid string, domain string, def *models.TaskDefinition) error {
	fake.desireTaskMutex.Lock()
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		logger lager.Logger
		guid   string
		domain string
		def    *models.TaskDefinition
	}{logger, guid, domain, def})
	fake.recordInvocation("DesireTask", []interface{}{logger, guid, domain, def})
	fake.desireTaskMutex.Unlock()
	if fake.DesireTaskStub != nil {
		return fake.DesireTaskStub(logger, guid, domain, def)
	} else {
		return fake.desireTaskReturns.result1
	}
}

func (fake *FakeInternalClient) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeInternalClient) DesireTaskArgsForCall(i int) (lager.Logger, string, string, *models.TaskDefinition) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return fake.desireTaskArgsForCall[i].logger, fake.desireTaskArgsForCall[i].guid, fake.desireTaskArgsForCall[i].domain, fake.desireTaskArgsForCall[i].def
}

func (fake *FakeInternalClient) DesireTaskReturns(result1 error) {
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Tasks(logger lager.Logger) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Tasks", []interface{}{logger})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub(logger)
	} else {
		return fake.tasksReturns.result1, fake.tasksReturns.result2
	}
}

func (fake *FakeInternalClient) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeInternalClient) TasksArgsForCall(i int) lager.Logger {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return fake.tasksArgsForCall[i].logger
}

func (fake *FakeInternalClient) TasksReturns(result1 []*models.Task, result2 error) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomain(logger lager.Logger, domain string) ([]*models.Task, error) {
	fake.tasksByDomainMutex.Lock()
	fake.tasksByDomainArgsForCall = append(fake.tasksByDomainArgsForCall, struct {
		logger lager.Logger
		domain string
	}{logger, domain})
	fake.recordInvocation("TasksByDomain", []interface{}{logger, domain})
	fake.tasksByDomainMutex.Unlock()
	if fake.TasksByDomainStub != nil {
		return fake.TasksByDomainStub(logger, domain)
	} else {
		return fake.tasksByDomainReturns.result1, fake.tasksByDomainReturns.result2
	}
}

func (fake *FakeInternalClient) TasksByDomainCallCount() int {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return len(fake.tasksByDomainArgsForCall)
}

func (fake *FakeInternalClient) TasksByDomainArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return fake.tasksByDomainArgsForCall[i].logger, fake.tasksByDomainArgsForCall[i].domain
}

func (fake *FakeInternalClient) TasksByDomainReturns(result1 []*models.Task, result2 error) {
	fake.TasksByDomainStub = nil
	fake.tasksByDomainReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellID(logger lager.Logger, cellId string) ([]*models.Task, error) {
	fake.tasksByCellIDMutex.Lock()
	fake.tasksByCellIDArgsForCall = append(fake.tasksByCellIDArgsForCall, struct {
		logger lager.Logger
		cellId string
	}{logger, cellId})
	fake.recordInvocation("TasksByCellID", []interface{}{logger, cellId})
	fake.tasksByCellIDMutex.Unlock()
	if fake.TasksByCellIDStub != nil {
		return fake.TasksByCellIDStub(logger, cellId)
	} else {
		return fake.tasksByCellIDReturns.result1, fake.tasksByCellIDReturns.result2
	}
}

func (fake *FakeInternalClient) TasksByCellIDCallCount() int {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return len(fake.tasksByCellIDArgsForCall)
}

func (fake *FakeInternalClient) TasksByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return fake.tasksByCellIDArgsForCall[i].logger, fake.tasksByCellIDArgsForCall[i].cellId
}

func (fake *FakeInternalClient) TasksByCellIDReturns(result1 []*models.Task, result2 error) {
	fake.TasksByCellIDStub = nil
	fake.tasksByCellIDReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuid(logger lager.Logger, guid string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		logger lager.Logger
		guid   string
	}{logger, guid})
	fake.recordInvocation("TaskByGuid", []interface{}{logger, guid})
	fake.taskByGuidMutex.Unlock()
	if fake.TaskByGuidStub != nil {
		return fake.TaskByGuidStub(logger, guid)
	} else {
		return fake.taskByGuidReturns.result1, fake.taskByGuidReturns.result2
	}
}

func (fake *FakeInternalClient) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeInternalClient) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return fake.taskByGuidArgsForCall[i].logger, fake.taskByGuidArgsForCall[i].guid
}

func (fake *FakeInternalClient) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CancelTask(logger lager.Logger, taskGuid string) error {
	fake.cancelTaskMutex.Lock()
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("CancelTask", []interface{}{logger, taskGuid})
	fake.cancelTaskMutex.Unlock()
	if fake.CancelTaskStub != nil {
		return fake.CancelTaskStub(logger, taskGuid)
	} else {
		return fake.cancelTaskReturns.result1
	}
}

func (fake *FakeInternalClient) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeInternalClient) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return fake.cancelTaskArgsForCall[i].logger, fake.cancelTaskArgsForCall[i].taskGuid
}

func (fake *FakeInternalClient) CancelTaskReturns(result1 error) {
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTask(logger lager.Logger, taskGuid string) error {
	fake.resolvingTaskMutex.Lock()
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("ResolvingTask", []interface{}{logger, taskGuid})
	fake.resolvingTaskMutex.Unlock()
	if fake.ResolvingTaskStub != nil {
		return fake.ResolvingTaskStub(logger, taskGuid)
	} else {
		return fake.resolvingTaskReturns.result1
	}
}

func (fake *FakeInternalClient) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeInternalClient) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return fake.resolvingTaskArgsForCall[i].logger, fake.resolvingTaskArgsForCall[i].taskGuid
}

func (fake *FakeInternalClient) ResolvingTaskReturns(result1 error) {
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTask(logger lager.Logger, taskGuid string) error {
	fake.deleteTaskMutex.Lock()
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("DeleteTask", []interface{}{logger, taskGuid})
	fake.deleteTaskMutex.Unlock()
	if fake.DeleteTaskStub != nil {
		return fake.DeleteTaskStub(logger, taskGuid)
	} else {
		return fake.deleteTaskReturns.result1
	}
}

func (fake *FakeInternalClient) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeInternalClient) DeleteTaskArgsForCall(i int) (lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return fake.deleteTaskArgsForCall[i].logger, fake.deleteTaskArgsForCall[i].taskGuid
}

func (fake *FakeInternalClient) DeleteTaskReturns(result1 error) {
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Domains(logger lager.Logger) ([]string, error) {
	fake.domainsMutex.Lock()
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Domains", []interface{}{logger})
	fake.domainsMutex.Unlock()
	if fake.DomainsStub != nil {
		return fake.DomainsStub(logger)
	} else {
		return fake.domainsReturns.result1, fake.domainsReturns.result2
	}
}

func (fake *FakeInternalClient) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeInternalClient) DomainsArgsForCall(i int) lager.Logger {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return fake.domainsArgsForCall[i].logger
}

func (fake *FakeInternalClient) DomainsReturns(result1 []string, result2 error) {
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) UpsertDomain(logger lager.Logger, domain string, ttl time.Duration) error {
	fake.upsertDomainMutex.Lock()
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		logger lager.Logger
		domain string
		ttl    time.Duration
	}{logger, domain, ttl})
	fake.recordInvocation("UpsertDomain", []interface{}{logger, domain, ttl})
	fake.upsertDomainMutex.Unlock()
	if fake.UpsertDomainStub != nil {
		return fake.UpsertDomainStub(logger, domain, ttl)
	} else {
		return fake.upsertDomainReturns.result1
	}
}

func (fake *FakeInternalClient) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeInternalClient) UpsertDomainArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return fake.upsertDomainArgsForCall[i].logger, fake.upsertDomainArgsForCall[i].domain, fake.upsertDomainArgsForCall[i].ttl
}

func (fake *FakeInternalClient) UpsertDomainReturns(result1 error) {
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ActualLRPGroups(arg1 lager.Logger, arg2 models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPGroups", []interface{}{arg1, arg2})
	fake.actualLRPGroupsMutex.Unlock()
	if fake.ActualLRPGroupsStub != nil {
		return fake.ActualLRPGroupsStub(arg1, arg2)
	} else {
		return fake.actualLRPGroupsReturns.result1, fake.actualLRPGroupsReturns.result2
	}
}

func (fake *FakeInternalClient) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return fake.actualLRPGroupsArgsForCall[i].arg1, fake.actualLRPGroupsArgsForCall[i].arg2
}

func (fake *FakeInternalClient) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuid(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("ActualLRPGroupsByProcessGuid", []interface{}{logger, processGuid})
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if fake.ActualLRPGroupsByProcessGuidStub != nil {
		return fake.ActualLRPGroupsByProcessGuidStub(logger, processGuid)
	} else {
		return fake.actualLRPGroupsByProcessGuidReturns.result1, fake.actualLRPGroupsByProcessGuidReturns.result2
	}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return fake.actualLRPGroupsByProcessGuidArgsForCall[i].logger, fake.actualLRPGroupsByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndex(logger lager.Logger, processGuid string, index int) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
	}{logger, processGuid, index})
	fake.recordInvocation("ActualLRPGroupByProcessGuidAndIndex", []interface{}{logger, processGuid, index})
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if fake.ActualLRPGroupByProcessGuidAndIndexStub != nil {
		return fake.ActualLRPGroupByProcessGuidAndIndexStub(logger, processGuid, index)
	} else {
		return fake.actualLRPGroupByProcessGuidAndIndexReturns.result1, fake.actualLRPGroupByProcessGuidAndIndexReturns.result2
	}
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, int) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].logger, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].processGuid, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].index
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) RetireActualLRP(logger lager.Logger, key *models.ActualLRPKey) error {
	fake.retireActualLRPMutex.Lock()
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("RetireActualLRP", []interface{}{logger, key})
	fake.retireActualLRPMutex.Unlock()
	if fake.RetireActualLRPStub != nil {
		return fake.RetireActualLRPStub(logger, key)
	} else {
		return fake.retireActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RetireActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return fake.retireActualLRPArgsForCall[i].logger, fake.retireActualLRPArgsForCall[i].key
}

func (fake *FakeInternalClient) RetireActualLRPReturns(result1 error) {
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesiredLRPs(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPs", []interface{}{arg1, arg2})
	fake.desiredLRPsMutex.Unlock()
	if fake.DesiredLRPsStub != nil {
		return fake.DesiredLRPsStub(arg1, arg2)
	} else {
		return fake.desiredLRPsReturns.result1, fake.desiredLRPsReturns.result2
	}
}

func (fake *FakeInternalClient) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPsArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return fake.desiredLRPsArgsForCall[i].arg1, fake.desiredLRPsArgsForCall[i].arg2
}

func (fake *FakeInternalClient) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuid(logger lager.Logger, processGuid string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{logger, processGuid})
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if fake.DesiredLRPByProcessGuidStub != nil {
		return fake.DesiredLRPByProcessGuidStub(logger, processGuid)
	} else {
		return fake.desiredLRPByProcessGuidReturns.result1, fake.desiredLRPByProcessGuidReturns.result2
	}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return fake.desiredLRPByProcessGuidArgsForCall[i].logger, fake.desiredLRPByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfos(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{arg1, arg2})
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if fake.DesiredLRPSchedulingInfosStub != nil {
		return fake.DesiredLRPSchedulingInfosStub(arg1, arg2)
	} else {
		return fake.desiredLRPSchedulingInfosReturns.result1, fake.desiredLRPSchedulingInfosReturns.result2
	}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return fake.desiredLRPSchedulingInfosArgsForCall[i].arg1, fake.desiredLRPSchedulingInfosArgsForCall[i].arg2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesireLRP(arg1 lager.Logger, arg2 *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}{arg1, arg2})
	fake.recordInvocation("DesireLRP", []interface{}{arg1, arg2})
	fake.desireLRPMutex.Unlock()
	if fake.DesireLRPStub != nil {
		return fake.DesireLRPStub(arg1, arg2)
	} else {
		return fake.desireLRPReturns.result1
	}
}

func (fake *FakeInternalClient) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeInternalClient) DesireLRPArgsForCall(i int) (lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return fake.desireLRPArgsForCall[i].arg1, fake.desireLRPArgsForCall[i].arg2
}

func (fake *FakeInternalClient) DesireLRPReturns(result1 error) {
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpdateDesiredLRP(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) error {
	fake.updateDesiredLRPMutex.Lock()
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}{logger, processGuid, update})
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{logger, processGuid, update})
	fake.updateDesiredLRPMutex.Unlock()
	if fake.UpdateDesiredLRPStub != nil {
		return fake.UpdateDesiredLRPStub(logger, processGuid, update)
	} else {
		return fake.updateDesiredLRPReturns.result1
	}
}

func (fake *FakeInternalClient) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return fake.updateDesiredLRPArgsForCall[i].logger, fake.updateDesiredLRPArgsForCall[i].processGuid, fake.updateDesiredLRPArgsForCall[i].update
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturns(result1 error) {
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRP(logger lager.Logger, processGuid string) error {
	fake.removeDesiredLRPMutex.Lock()
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{logger, processGuid})
	fake.removeDesiredLRPMutex.Unlock()
	if fake.RemoveDesiredLRPStub != nil {
		return fake.RemoveDesiredLRPStub(logger, processGuid)
	} else {
		return fake.removeDesiredLRPReturns.result1
	}
}

func (fake *FakeInternalClient) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return fake.removeDesiredLRPArgsForCall[i].logger, fake.removeDesiredLRPArgsForCall[i].processGuid
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturns(result1 error) {
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) SubscribeToEvents(logger lager.Logger) (events.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("SubscribeToEvents", []interface{}{logger})
	fake.subscribeToEventsMutex.Unlock()
	if fake.SubscribeToEventsStub != nil {
		return fake.SubscribeToEventsStub(logger)
	} else {
		return fake.subscribeToEventsReturns.result1, fake.subscribeToEventsReturns.result2
	}
}

func (fake *FakeInternalClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return fake.subscribeToEventsArgsForCall[i].logger
}

func (fake *FakeInternalClient) SubscribeToEventsReturns(result1 events.EventSource, result2 error) {
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) Ping(logger lager.Logger) bool {
	fake.pingMutex.Lock()
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Ping", []interface{}{logger})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub(logger)
	} else {
		return fake.pingReturns.result1
	}
}

func (fake *FakeInternalClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeInternalClient) PingArgsForCall(i int) lager.Logger {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return fake.pingArgsForCall[i].logger
}

func (fake *FakeInternalClient) PingReturns(result1 bool) {
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) Cells(logger lager.Logger) ([]*models.CellPresence, error) {
	fake.cellsMutex.Lock()
	fake.cellsArgsForCall = append(fake.cellsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Cells", []interface{}{logger})
	fake.cellsMutex.Unlock()
	if fake.CellsStub != nil {
		return fake.CellsStub(logger)
	} else {
		return fake.cellsReturns.result1, fake.cellsReturns.result2
	}
}

func (fake *FakeInternalClient) CellsCallCount() int {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return len(fake.cellsArgsForCall)
}

func (fake *FakeInternalClient) CellsArgsForCall(i int) lager.Logger {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return fake.cellsArgsForCall[i].logger
}

func (fake *FakeInternalClient) CellsReturns(result1 []*models.CellPresence, result2 error) {
	fake.CellsStub = nil
	fake.cellsReturns = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToDesiredLRPEvents(logger lager.Logger) (events.EventSource, error) {
	fake.subscribeToDesiredLRPEventsMutex.Lock()
	fake.subscribeToDesiredLRPEventsArgsForCall = append(fake.subscribeToDesiredLRPEventsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("SubscribeToDesiredLRPEvents", []interface{}{logger})
	fake.subscribeToDesiredLRPEventsMutex.Unlock()
	if fake.SubscribeToDesiredLRPEventsStub != nil {
		return fake.SubscribeToDesiredLRPEventsStub(logger)
	} else {
		return fake.subscribeToDesiredLRPEventsReturns.result1, fake.subscribeToDesiredLRPEventsReturns.result2
	}
}

func (fake *FakeInternalClient) SubscribeToDesiredLRPEventsCallCount() int {
	fake.subscribeToDesiredLRPEventsMutex.RLock()
	defer fake.subscribeToDesiredLRPEventsMutex.RUnlock()
	return len(fake.subscribeToDesiredLRPEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToDesiredLRPEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToDesiredLRPEventsMutex.RLock()
	defer fake.subscribeToDesiredLRPEventsMutex.RUnlock()
	return fake.subscribeToDesiredLRPEventsArgsForCall[i].logger
}

func (fake *FakeInternalClient) SubscribeToDesiredLRPEventsReturns(result1 events.EventSource, result2 error) {
	fake.SubscribeToDesiredLRPEventsStub = nil
	fake.subscribeToDesiredLRPEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToActualLRPEvents(logger lager.Logger) (events.EventSource, error) {
	fake.subscribeToActualLRPEventsMutex.Lock()
	fake.subscribeToActualLRPEventsArgsForCall = append(fake.subscribeToActualLRPEventsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("SubscribeToActualLRPEvents", []interface{}{logger})
	fake.subscribeToActualLRPEventsMutex.Unlock()
	if fake.SubscribeToActualLRPEventsStub != nil {
		return fake.SubscribeToActualLRPEventsStub(logger)
	} else {
		return fake.subscribeToActualLRPEventsReturns.result1, fake.subscribeToActualLRPEventsReturns.result2
	}
}

func (fake *FakeInternalClient) SubscribeToActualLRPEventsCallCount() int {
	fake.subscribeToActualLRPEventsMutex.RLock()
	defer fake.subscribeToActualLRPEventsMutex.RUnlock()
	return len(fake.subscribeToActualLRPEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToActualLRPEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToActualLRPEventsMutex.RLock()
	defer fake.subscribeToActualLRPEventsMutex.RUnlock()
	return fake.subscribeToActualLRPEventsArgsForCall[i].logger
}

func (fake *FakeInternalClient) SubscribeToActualLRPEventsReturns(result1 events.EventSource, result2 error) {
	fake.SubscribeToActualLRPEventsStub = nil
	fake.subscribeToActualLRPEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ClaimActualLRP(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error {
	fake.claimActualLRPMutex.Lock()
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("ClaimActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, instanceKey)
	} else {
		return fake.claimActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeInternalClient) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeInternalClient) ClaimActualLRPReturns(result1 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) error {
	fake.startActualLRPMutex.Lock()
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{logger, key, instanceKey, netInfo})
	fake.recordInvocation("StartActualLRP", []interface{}{logger, key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, key, instanceKey, netInfo)
	} else {
		return fake.startActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeInternalClient) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeInternalClient) StartActualLRPReturns(result1 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, errorMessage string) error {
	fake.crashActualLRPMutex.Lock()
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		instanceKey  *models.ActualLRPInstanceKey
		errorMessage string
	}{logger, key, instanceKey, errorMessage})
	fake.recordInvocation("CrashActualLRP", []interface{}{logger, key, instanceKey, errorMessage})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, key, instanceKey, errorMessage)
	} else {
		return fake.crashActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeInternalClient) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeInternalClient) CrashActualLRPReturns(result1 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, errorMessage string) error {
	fake.failActualLRPMutex.Lock()
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		errorMessage string
	}{logger, key, errorMessage})
	fake.recordInvocation("FailActualLRP", []interface{}{logger, key, errorMessage})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, errorMessage)
	} else {
		return fake.failActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeInternalClient) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeInternalClient) FailActualLRPReturns(result1 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRP(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("RemoveActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index, instanceKey)
	} else {
		return fake.removeActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index, fake.removeActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeInternalClient) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	fake.evacuateClaimedActualLRPArgsForCall = append(fake.evacuateClaimedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("EvacuateClaimedActualLRP", []interface{}{arg1, arg2, arg3})
	fake.evacuateClaimedActualLRPMutex.Unlock()
	if fake.EvacuateClaimedActualLRPStub != nil {
		return fake.EvacuateClaimedActualLRPStub(arg1, arg2, arg3)
	} else {
		return fake.evacuateClaimedActualLRPReturns.result1, fake.evacuateClaimedActualLRPReturns.result2
	}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPCallCount() int {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return len(fake.evacuateClaimedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return fake.evacuateClaimedActualLRPArgsForCall[i].arg1, fake.evacuateClaimedActualLRPArgsForCall[i].arg2, fake.evacuateClaimedActualLRPArgsForCall[i].arg3
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateClaimedActualLRPStub = nil
	fake.evacuateClaimedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 *models.ActualLRPNetInfo, arg5 uint64) (bool, error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	fake.evacuateRunningActualLRPArgsForCall = append(fake.evacuateRunningActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
		arg5 uint64
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("EvacuateRunningActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.evacuateRunningActualLRPMutex.Unlock()
	if fake.EvacuateRunningActualLRPStub != nil {
		return fake.EvacuateRunningActualLRPStub(arg1, arg2, arg3, arg4, arg5)
	} else {
		return fake.evacuateRunningActualLRPReturns.result1, fake.evacuateRunningActualLRPReturns.result2
	}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPCallCount() int {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return len(fake.evacuateRunningActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return fake.evacuateRunningActualLRPArgsForCall[i].arg1, fake.evacuateRunningActualLRPArgsForCall[i].arg2, fake.evacuateRunningActualLRPArgsForCall[i].arg3, fake.evacuateRunningActualLRPArgsForCall[i].arg4, fake.evacuateRunningActualLRPArgsForCall[i].arg5
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateRunningActualLRPStub = nil
	fake.evacuateRunningActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	fake.evacuateStoppedActualLRPArgsForCall = append(fake.evacuateStoppedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("EvacuateStoppedActualLRP", []interface{}{arg1, arg2, arg3})
	fake.evacuateStoppedActualLRPMutex.Unlock()
	if fake.EvacuateStoppedActualLRPStub != nil {
		return fake.EvacuateStoppedActualLRPStub(arg1, arg2, arg3)
	} else {
		return fake.evacuateStoppedActualLRPReturns.result1, fake.evacuateStoppedActualLRPReturns.result2
	}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPCallCount() int {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return len(fake.evacuateStoppedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return fake.evacuateStoppedActualLRPArgsForCall[i].arg1, fake.evacuateStoppedActualLRPArgsForCall[i].arg2, fake.evacuateStoppedActualLRPArgsForCall[i].arg3
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateStoppedActualLRPStub = nil
	fake.evacuateStoppedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 string) (bool, error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	fake.evacuateCrashedActualLRPArgsForCall = append(fake.evacuateCrashedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("EvacuateCrashedActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.evacuateCrashedActualLRPMutex.Unlock()
	if fake.EvacuateCrashedActualLRPStub != nil {
		return fake.EvacuateCrashedActualLRPStub(arg1, arg2, arg3, arg4)
	} else {
		return fake.evacuateCrashedActualLRPReturns.result1, fake.evacuateCrashedActualLRPReturns.result2
	}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPCallCount() int {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return len(fake.evacuateCrashedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return fake.evacuateCrashedActualLRPArgsForCall[i].arg1, fake.evacuateCrashedActualLRPArgsForCall[i].arg2, fake.evacuateCrashedActualLRPArgsForCall[i].arg3, fake.evacuateCrashedActualLRPArgsForCall[i].arg4
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateCrashedActualLRPStub = nil
	fake.evacuateCrashedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveEvacuatingActualLRP", []interface{}{arg1, arg2, arg3})
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if fake.RemoveEvacuatingActualLRPStub != nil {
		return fake.RemoveEvacuatingActualLRPStub(arg1, arg2, arg3)
	} else {
		return fake.removeEvacuatingActualLRPReturns.result1
	}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return fake.removeEvacuatingActualLRPArgsForCall[i].arg1, fake.removeEvacuatingActualLRPArgsForCall[i].arg2, fake.removeEvacuatingActualLRPArgsForCall[i].arg3
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ConvergeLRPs(logger lager.Logger) error {
	fake.convergeLRPsMutex.Lock()
	fake.convergeLRPsArgsForCall = append(fake.convergeLRPsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("ConvergeLRPs", []interface{}{logger})
	fake.convergeLRPsMutex.Unlock()
	if fake.ConvergeLRPsStub != nil {
		return fake.ConvergeLRPsStub(logger)
	} else {
		return fake.convergeLRPsReturns.result1
	}
}

func (fake *FakeInternalClient) ConvergeLRPsCallCount() int {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return len(fake.convergeLRPsArgsForCall)
}

func (fake *FakeInternalClient) ConvergeLRPsArgsForCall(i int) lager.Logger {
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	return fake.convergeLRPsArgsForCall[i].logger
}

func (fake *FakeInternalClient) ConvergeLRPsReturns(result1 error) {
	fake.ConvergeLRPsStub = nil
	fake.convergeLRPsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ConvergeTasks(logger lager.Logger, kickTaskDuration time.Duration, expirePendingTaskDuration time.Duration, expireCompletedTaskDuration time.Duration) error {
	fake.convergeTasksMutex.Lock()
	fake.convergeTasksArgsForCall = append(fake.convergeTasksArgsForCall, struct {
		logger                      lager.Logger
		kickTaskDuration            time.Duration
		expirePendingTaskDuration   time.Duration
		expireCompletedTaskDuration time.Duration
	}{logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.recordInvocation("ConvergeTasks", []interface{}{logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration})
	fake.convergeTasksMutex.Unlock()
	if fake.ConvergeTasksStub != nil {
		return fake.ConvergeTasksStub(logger, kickTaskDuration, expirePendingTaskDuration, expireCompletedTaskDuration)
	} else {
		return fake.convergeTasksReturns.result1
	}
}

func (fake *FakeInternalClient) ConvergeTasksCallCount() int {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return len(fake.convergeTasksArgsForCall)
}

func (fake *FakeInternalClient) ConvergeTasksArgsForCall(i int) (lager.Logger, time.Duration, time.Duration, time.Duration) {
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	return fake.convergeTasksArgsForCall[i].logger, fake.convergeTasksArgsForCall[i].kickTaskDuration, fake.convergeTasksArgsForCall[i].expirePendingTaskDuration, fake.convergeTasksArgsForCall[i].expireCompletedTaskDuration
}

func (fake *FakeInternalClient) ConvergeTasksReturns(result1 error) {
	fake.ConvergeTasksStub = nil
	fake.convergeTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartTask(logger lager.Logger, taskGuid string, cellID string) (bool, error) {
	fake.startTaskMutex.Lock()
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
		cellID   string
	}{logger, taskGuid, cellID})
	fake.recordInvocation("StartTask", []interface{}{logger, taskGuid, cellID})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(logger, taskGuid, cellID)
	} else {
		return fake.startTaskReturns.result1, fake.startTaskReturns.result2
	}
}

func (fake *FakeInternalClient) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeInternalClient) StartTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].logger, fake.startTaskArgsForCall[i].taskGuid, fake.startTaskArgsForCall[i].cellID
}

func (fake *FakeInternalClient) StartTaskReturns(result1 bool, result2 error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) FailTask(logger lager.Logger, taskGuid string, failureReason string) error {
	fake.failTaskMutex.Lock()
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}{logger, taskGuid, failureReason})
	fake.recordInvocation("FailTask", []interface{}{logger, taskGuid, failureReason})
	fake.failTaskMutex.Unlock()
	if fake.FailTaskStub != nil {
		return fake.FailTaskStub(logger, taskGuid, failureReason)
	} else {
		return fake.failTaskReturns.result1
	}
}

func (fake *FakeInternalClient) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeInternalClient) FailTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return fake.failTaskArgsForCall[i].logger, fake.failTaskArgsForCall[i].taskGuid, fake.failTaskArgsForCall[i].failureReason
}

func (fake *FakeInternalClient) FailTaskReturns(result1 error) {
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTask(logger lager.Logger, taskGuid string, cellId string, failed bool, failureReason string, result string) error {
	fake.completeTaskMutex.Lock()
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.recordInvocation("CompleteTask", []interface{}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.completeTaskMutex.Unlock()
	if fake.CompleteTaskStub != nil {
		return fake.CompleteTaskStub(logger, taskGuid, cellId, failed, failureReason, result)
	} else {
		return fake.completeTaskReturns.result1
	}
}

func (fake *FakeInternalClient) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeInternalClient) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.completeTaskArgsForCall[i].logger, fake.completeTaskArgsForCall[i].taskGuid, fake.completeTaskArgsForCall[i].cellId, fake.completeTaskArgsForCall[i].failed, fake.completeTaskArgsForCall[i].failureReason, fake.completeTaskArgsForCall[i].result
}

func (fake *FakeInternalClient) CompleteTaskReturns(result1 error) {
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	fake.subscribeToDesiredLRPEventsMutex.RLock()
	defer fake.subscribeToDesiredLRPEventsMutex.RUnlock()
	fake.subscribeToActualLRPEventsMutex.RLock()
	defer fake.subscribeToActualLRPEventsMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	fake.convergeLRPsMutex.RLock()
	defer fake.convergeLRPsMutex.RUnlock()
	fake.convergeTasksMutex.RLock()
	defer fake.convergeTasksMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeInternalClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bbs.InternalClient = new(FakeInternalClient)
