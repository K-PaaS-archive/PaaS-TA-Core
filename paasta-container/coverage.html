
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloudfoundry/dropsonde/runtime_stats/runtime_stats.go (75.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package runtime_stats

import (
        "log"
        "runtime"
        "time"
        "fmt"
        "strconv"
        "strings"

        "github.com/cloudfoundry/sonde-go/events"
        "github.com/gogo/protobuf/proto"

        "github.com/shirou/gopsutil/host"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/load"
        "github.com/shirou/gopsutil/mem"
        "github.com/shirou/gopsutil/disk"
        "github.com/shirou/gopsutil/net"
        "github.com/shirou/gopsutil/process"
        "github.com/bradfitz/slice"
)

type EventEmitter interface {
        Emit(events.Event) error
}

type processStat struct {
        pid                 int32
        ppid                 int32
        startTime        string
        memUsage         uint64
        name                 string
}

type RuntimeStats struct {
        emitter  EventEmitter
        interval time.Duration
}

func NewRuntimeStats(emitter EventEmitter, interval time.Duration) *RuntimeStats <span class="cov8" title="1">{
        return &amp;RuntimeStats{
                emitter:  emitter,
                interval: interval,
        }
}</span>

func (rs *RuntimeStats) Run(stopChan &lt;-chan struct{}) <span class="cov8" title="1">{
        ticker := time.NewTicker(rs.interval)

        defer ticker.Stop()
        for </span><span class="cov8" title="1">{
                //Add CPU Metrics
                rs.emitCpuMetrics()
                //Add Disk Metrics
                rs.emitDiskMetrics()
                //Add Network Metrics
                rs.emitNetworkMetrics()
                //Add Process Metrics
                rs.emitProcessMetrics()

                rs.emit("numCPUS", float64(runtime.NumCPU()))
                rs.emit("numGoRoutines", float64(runtime.NumGoroutine()))
                rs.emitMemMetrics()

                select </span>{
                <span class="cov0" title="0">case &lt;-ticker.C:</span>
                <span class="cov8" title="1">case &lt;-stopChan:
                        return</span>
                }
        }
}

func (rs *RuntimeStats) emitMemMetrics() <span class="cov8" title="1">{
        /*stats := new(runtime.MemStats)
        runtime.ReadMemStats(stats)

        rs.emit("memoryStats.numBytesAllocatedHeap", float64(stats.HeapAlloc))
        rs.emit("memoryStats.numBytesAllocatedStack", float64(stats.StackInuse))
        rs.emit("memoryStats.numBytesAllocated", float64(stats.Alloc))
        rs.emit("memoryStats.numMallocs", float64(stats.Mallocs))
        rs.emit("memoryStats.numFrees", float64(stats.Frees))
        rs.emit("memoryStats.lastGCPauseTimeNS", float64(stats.PauseNs[(stats.NumGC+255)%256]))*/
        m, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("MemStats: failed to emit: %v", err)
        }</span>
        <span class="cov8" title="1">rs.emit("memoryStats.TotalMemory", float64(m.Total))
        rs.emit("memoryStats.AvailableMemory", float64(m.Available))
        rs.emit("memoryStats.UsedMemory", float64(m.Used))
        rs.emit("memoryStats.UsedPercent", float64(m.UsedPercent))</span>
}

func (rs *RuntimeStats) emit(name string, value float64) <span class="cov8" title="1">{
        err := rs.emitter.Emit(&amp;events.ValueMetric{
                Name:  &amp;name,
                Value: &amp;value,
                Unit:  proto.String("count"),
        })
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("RuntimeStats: failed to emit: %v", err)
        }</span>
}

/*
 Description: VM - CPU Info metrics
 */
func (rs *RuntimeStats) emitCpuMetrics() <span class="cov8" title="1">{
        numcpu := runtime.NumCPU()
        duration := time.Duration(100) * time.Millisecond //.Second
        c, err := cpu.Percent(duration, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("getting cpu metrics error %v", err.Error())
                //log.Fatalf("getting cpu metrics error %v", err)
                return
        }</span>

        <span class="cov8" title="1">for k, percent := range c </span><span class="cov8" title="1">{
                // Check for slightly greater then 100% to account for any rounding issues.
                if percent &lt; 0.0 || percent &gt; 100.0001 * float64(numcpu) </span><span class="cov0" title="0">{
                        log.Println("CPUPercent value is invalid: %f", percent)
                        //log.Fatalf("CPUPercent value is invalid: %f", percent)
                }</span><span class="cov8" title="1">else{
                        rs.emit(fmt.Sprintf("cpuStats.%d", k), float64(percent))
                }</span>
                //log.Println("%d cpu %f", k, percent)
        }

        //============ CPU Load Average : Only support linux &amp; freebsd ==============
        <span class="cov8" title="1">h, err := host.Info()
        if h.OS == "linux" || h.OS == "freebsd"</span><span class="cov8" title="1">{
                loadAvgStat, err := load.Avg()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("LoadAvgStats: failed to emit: %v", err)
                }</span>
                <span class="cov8" title="1">rs.emit("loadavg1", float64(loadAvgStat.Load1))
                rs.emit("loadavg5", float64(loadAvgStat.Load5))
                rs.emit("loadavg15", float64(loadAvgStat.Load15))</span>
        }
        //===========================================================================

}

/*
 Description: VM - Disk/IO Info metrics
 */
func (rs *RuntimeStats) emitDiskMetrics() <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                var pathKey []string
                diskios, _ := disk.IOCounters()

                //Newly Added - Disk I/O (2017.04)
                for key, value := range diskios</span><span class="cov0" title="0">{
                        pathKey = append(pathKey, key)
                        rs.emit(fmt.Sprintf("diskIOStats.%s.readCount", key), float64(value.ReadCount))
                        rs.emit(fmt.Sprintf("diskIOStats.%s.writeCount", key), float64(value.WriteCount))
                        rs.emit(fmt.Sprintf("diskIOStats.%s.readBytes", key), float64(value.ReadBytes))
                        rs.emit(fmt.Sprintf("diskIOStats.%s.writeBytes", key), float64(value.WriteBytes))
                        rs.emit(fmt.Sprintf("diskIOStats.%s.readTime", key), float64(value.ReadTime))
                        rs.emit(fmt.Sprintf("diskIOStats.%s.writeTime", key), float64(value.WriteTime))
                        rs.emit(fmt.Sprintf("diskIOStats.%s.ioTime", key), float64(value.IoTime))
                }</span>

                <span class="cov0" title="0">for _, value := range pathKey </span><span class="cov0" title="0">{
                        d, err := disk.Usage(value)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println("getting disk info error %v", err.Error())
                                //log.Fatalf("getting disk info error %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">rs.emit(fmt.Sprintf("diskStats.windows.%s.Total", d.Path), float64(d.Total))
                        rs.emit(fmt.Sprintf("diskStats.windows.%s.Used", d.Path), float64(d.Used))
                        rs.emit(fmt.Sprintf("diskStats.windows.%s.Available", d.Path), float64(d.Free))
                        rs.emit(fmt.Sprintf("diskStats.windows.%s.Usage", d.Path), float64(d.UsedPercent))</span>
                }

        }<span class="cov8" title="1">else{
                diskparts, err := disk.Partitions(false)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("get disk partitions error: %v", err)
                }</span>
                <span class="cov8" title="1">for _, partition := range diskparts </span><span class="cov8" title="1">{
                        //fmt.Println("partition KEY:", key, "value:", partition)
                        if partition.Mountpoint == "/" </span><span class="cov8" title="1">{
                                mountpoints := strings.Split(partition.Device, "/")
                                d, err := disk.Usage(partition.Mountpoint)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println("getting disk info error %v", err.Error())
                                        //log.Fatalf("getting disk info error %v", err)
                                        return
                                }</span>
                                //log.Printf("path : %s, fstype : %s, total : %d, used : %d, avail : %d, usage : %f", d.Path, d.Fstype, d.Total, d.Used, d.Free, d.UsedPercent)
                                <span class="cov8" title="1">rs.emit("diskStats.Total", float64(d.Total))
                                rs.emit("diskStats.Used", float64(d.Used))
                                rs.emit("diskStats.Available", float64(d.Free))
                                rs.emit("diskStats.Usage", float64(d.UsedPercent))

                                //Newly Added - Disk I/O (2017.04)
                                diskios, _ := disk.IOCounters()
                                for key, value := range diskios </span><span class="cov8" title="1">{
                                        if mountpoints[len(mountpoints) - 1] == key </span><span class="cov8" title="1">{
                                                //log.Printf("diskio key : %s, diskio value : %v", key, value)
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.readCount", key), float64(value.ReadCount))
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.writeCount", key), float64(value.WriteCount))
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.readBytes", key), float64(value.ReadBytes))
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.writeBytes", key), float64(value.WriteBytes))
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.readTime", key), float64(value.ReadTime))
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.writeTime", key), float64(value.WriteTime))
                                                rs.emit(fmt.Sprintf("diskIOStats.%s.ioTime", key), float64(value.IoTime))

                                        }</span>
                                }

                        }
                }
        }
}


/*
Newly Added - Network I/O (2017.04)
Description: VM - Network Interface &amp; I/O Info metrics
*/
func (rs *RuntimeStats) emitNetworkMetrics() <span class="cov8" title="1">{
        nifs, err := net.Interfaces()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("getting network interface info error %v", err.Error())
                //log.Fatalf("getting network interface info error %v", err)
                return
        }</span>

        <span class="cov8" title="1">for _, intf := range nifs </span><span class="cov8" title="1">{
                rs.emit(fmt.Sprintf("networkInterface.%s.%s", intf.Name, "MTU"), float64(intf.MTU))
        }</span>

        <span class="cov8" title="1">ios, err := net.IOCounters(true)
        for _, value := range ios </span><span class="cov8" title="1">{
                rs.emit(fmt.Sprintf("networkIOStats.%s.bytesRecv", value.Name), float64(value.BytesRecv))
                rs.emit(fmt.Sprintf("networkIOStats.%s.bytesSent", value.Name), float64(value.BytesSent))
                rs.emit(fmt.Sprintf("networkIOStats.%s.packetRecv", value.Name), float64(value.PacketsRecv))
                rs.emit(fmt.Sprintf("networkIOStats.%s.packetSent", value.Name), float64(value.PacketsSent))
                rs.emit(fmt.Sprintf("networkIOStats.%s.dropIn", value.Name), float64(value.Dropin))
                rs.emit(fmt.Sprintf("networkIOStats.%s.dropOut", value.Name), float64(value.Dropout))
                rs.emit(fmt.Sprintf("networkIOStats.%s.errIn", value.Name), float64(value.Errin))
                rs.emit(fmt.Sprintf("networkIOStats.%s.errOut", value.Name), float64(value.Errout))
        }</span>
}

/*
Newly Added - Network I/O (2017.04)
Description: VM - Process Info metrics
*/
func (rs *RuntimeStats) emitProcessMetrics() <span class="cov8" title="1">{
        procs, err := process.Pids()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("getting processes error %v", err.Error())
                //log.Fatalf("getting processes error %v", err)
                return
        }</span>

        <span class="cov8" title="1">pStatArray := make([]processStat, 0)

        for _, value :=range procs</span><span class="cov8" title="1">{
                p, err := process.NewProcess(value)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("getting single process info error %v", err.Error())
                        //log.Fatalf("getting single process info error %v", err)
                        return
                }</span><span class="cov8" title="1">else{
                        var pStat processStat
                        ct, _:= p.CreateTime()
                        s_timestamp := strconv.FormatInt(ct, 10)

                        //window환경에서는 모든 프로세스를 조회하기 때문에 많은 시간이 소요된다.
                        //이를 방지하기 위해 프로세스시작 시간을 통해 제어한다.
                        if len(s_timestamp) &gt;= 10</span><span class="cov8" title="1">{
                                pStat.startTime = s_timestamp[:10]
                                pStat.pid = p.Pid
                                pp, _ := p.Ppid()
                                pStat.ppid = pp

                                pname, _ := p.Name()
                                pStat.name = pname

                                m,err := p.MemoryInfo()
                                if err == nil </span><span class="cov8" title="1">{
                                        pStat.memUsage = m.RSS
                                }</span>
                                <span class="cov8" title="1">pStatArray = append(pStatArray, pStat)</span>
                        }
                }
        }

        //Memroy 점유 크기별로 Sorting
        <span class="cov8" title="1">slice.Sort(pStatArray[:], func(i, j int) bool </span><span class="cov8" title="1">{
                return pStatArray[i].memUsage &gt; pStatArray[j].memUsage
        }</span>)

        <span class="cov8" title="1">var index int
        for _, ps := range pStatArray </span><span class="cov8" title="1">{
                if index &gt; 20 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">rs.emit(fmt.Sprintf("processStats.%d.%s.pid",index, ps.name), float64(ps.pid))
                rs.emit(fmt.Sprintf("processStats.%d.%s.ppid",index, ps.name), float64(ps.ppid))
                if f, err := strconv.ParseFloat(ps.startTime, 64); err == nil </span><span class="cov8" title="1">{
                        rs.emit(fmt.Sprintf("processStats.%d.%s.startTime", index, ps.name),  f)
                }</span>
                <span class="cov8" title="1">rs.emit(fmt.Sprintf("processStats.%d.%s.memUsage",index, ps.name), float64(ps.memUsage))
                index++</span>
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
